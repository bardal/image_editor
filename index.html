<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Image Editor</title>
    <script src="https://lib.arvancloud.ir/heic2any/0.0.3/heic2any.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f4f4f4; }
        .container { 
            max-width: 90vw; 
            height: 95vh;
            margin: 10px auto; 
            background: #fff; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 8px #0001; 
            display: flex;
            flex-direction: column;
        }
        .canvas-container { 
            flex: 1;
            width: 100%; 
            max-width: 100%; 
            overflow: hidden; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            background: #eee; 
            margin-top: 10px;
            min-height: 400px;
        }
        #canvas { 
            width: 100%; 
            height: 100%; 
            max-width: 100%; 
            display: block; 
            cursor: crosshair; 
        }
        .toolbar { margin-bottom: 10px; display: flex; flex-wrap: wrap; gap: 8px; }
        .toolbar label { margin-right: 4px; }
        .toolbar input[type="color"] { vertical-align: middle; }
        .toolbar input[type="number"] { width: 50px; }
        .loading { display: none; color: #666; font-style: italic; }
        .heic-info { font-size: 12px; color: #666; margin-top: 5px; }
        .heic-warning { font-size: 11px; color: #ff6b6b; margin-top: 3px; }
        .heic-help { font-size: 11px; color: #4a90e2; margin-top: 3px; cursor: pointer; text-decoration: underline; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
        .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border-radius: 8px; width: 80%; max-width: 500px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover { color: #000; }
        .button-group { display: flex; gap: 5px; }
        .button-group button { padding: 5px 10px; border: 1px solid #ccc; background: #f8f8f8; cursor: pointer; border-radius: 3px; }
        .button-group button:hover { background: #e8e8e8; }
        .button-group button:disabled { opacity: 0.5; cursor: not-allowed; }
        .image-info { font-size: 11px; color: #666; margin-top: 5px; text-align: center; }
        
        @media (max-width: 768px) {
            .container { 
                margin: 5px; 
                padding: 15px; 
                height: 98vh;
            }
            .toolbar { gap: 5px; }
            .toolbar label { font-size: 12px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Simple Image Editor</h2>
        <div class="toolbar">
            <input type="file" id="imgLoader" accept="image/*,.heic,.heif">
            <div class="loading" id="loading">Processing image...</div>
            <div class="heic-info">Supports: JPEG, PNG, GIF, WebP, HEIC</div>
            <div class="heic-warning">Note: HEIC files are automatically converted to JPEG</div>
            <div class="heic-help" onclick="showHeicHelp()">HEIC conversion info</div>
            <label><input type="radio" name="tool" value="select" checked> Select</label>
            <label><input type="radio" name="tool" value="rect"> Rectangle</label>
            <label><input type="radio" name="tool" value="ellipse"> Ellipse</label>
            <label><input type="radio" name="tool" value="arrow"> Arrow</label>
            <label><input type="radio" name="tool" value="text"> Text</label>
            <input type="color" id="color" value="#ff0000">
            <input type="number" id="size" value="3" min="1" max="20">
            <div class="button-group">
                <button id="undo" disabled>Undo</button>
                <button id="delete" disabled>Delete</button>
            </div>
            <button id="clear">Clear</button>
            <button id="download">Download</button>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        <div class="image-info" id="imageInfo">No image loaded</div>
    </div>

    <!-- HEIC Help Modal -->
    <div id="heicModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeHeicHelp()">&times;</span>
            <h3>HEIC Image Support</h3>
            <p><strong>This editor supports HEIC files!</strong> Using the heic2any library.</p>
            <ul>
                <li><strong>How it works:</strong> Converts HEIC to JPEG in your browser</li>
                <li><strong>Privacy:</strong> No files uploaded to servers</li>
                <li><strong>Quality:</strong> High-quality JPEG conversion</li>
                <li><strong>Browser support:</strong> All modern browsers</li>
            </ul>
            <p><strong>Supported formats:</strong></p>
            <ul>
                <li>HEIC/HEIF (iPhone photos)</li>
                <li>JPEG, PNG, GIF, WebP</li>
                <li>All standard image formats</li>
            </ul>
            <p><strong>If HEIC doesn't work:</strong></p>
            <ul>
                <li>Try refreshing the page</li>
                <li>Use a modern browser (Chrome, Firefox, Safari, Edge)</li>
                <li>Check that JavaScript is enabled</li>
                <li>Try a different HEIC file</li>
            </ul>
            <p><em>HEIC files from iPhones and other Apple devices work seamlessly.</em></p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');
        const undoBtn = document.getElementById('undo');
        const deleteBtn = document.getElementById('delete');
        const imageInfo = document.getElementById('imageInfo');
        let img = null;
        let drawing = false;
        let startX, startY;
        let tool = 'select';
        let color = document.getElementById('color').value;
        let size = parseInt(document.getElementById('size').value);
        let textInput = '';
        let shapes = [];
        let selectedShape = null;
        let dragOffset = { x: 0, y: 0 };
        let isDragging = false;
        let canvasScale = { x: 1, y: 1 };
        let canvasOffset = { x: 0, y: 0 };
        let rotationHandle = null;
        let isRotating = false;
        let rotationCenter = { x: 0, y: 0 };
        let rotationStartAngle = 0;
        let mouseDownPos = { x: 0, y: 0 };
        let hasMoved = false;
        let hadSelectionBeforeMouseDown = false;
        let isResizing = false;
        let resizeHandle = null;
        let originalShape = null;
        let hasEdited = false;

        // Convert HEIC to JPEG using heic2any
        async function convertHeicToJpeg(file) {
            if (typeof heic2any === 'undefined') {
                throw new Error('HEIC library not loaded');
            }
            
            console.log('Converting HEIC file:', file.name);
            return await heic2any({
                blob: file,
                toType: 'image/jpeg',
                quality: 0.9
            });
        }

        // Calculate canvas size to fit container
        function calculateCanvasSize() {
            const container = document.querySelector('.canvas-container');
            const containerWidth = container.clientWidth;
            const viewportHeight = window.innerHeight;
            const toolbarHeight = 120; // Approximate toolbar height
            const margins = 80; // Account for margins and padding
            const availableHeight = viewportHeight - toolbarHeight - margins;
            
            return {
                width: containerWidth,
                height: Math.max(400, availableHeight) // Minimum 400px height
            };
        }

        // Resize canvas to fit container
        function resizeCanvas() {
            const size = calculateCanvasSize();
            canvas.width = size.width;
            canvas.height = size.height;
            redraw();
        }

        // Convert screen coordinates to canvas coordinates
        function screenToCanvas(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (screenX - rect.left) * (canvas.width / rect.width),
                y: (screenY - rect.top) * (canvas.height / rect.height)
            };
        }

        // Show HEIC help modal
        function showHeicHelp() {
            document.getElementById('heicModal').style.display = 'block';
        }

        // Close HEIC help modal
        function closeHeicHelp() {
            document.getElementById('heicModal').style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('heicModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // Check if point is inside shape
        function isPointInShape(x, y, shape) {
            if (shape.type === 'rect' || shape.type === 'ellipse') {
                const left = Math.min(shape.x, shape.x + shape.w);
                const right = Math.max(shape.x, shape.x + shape.w);
                const top = Math.min(shape.y, shape.y + shape.h);
                const bottom = Math.max(shape.y, shape.y + shape.h);
                return x >= left && x <= right && y >= top && y <= bottom;
            } else if (shape.type === 'text') {
                // Simple text selection (approximate)
                const textWidth = shape.text.length * 8;
                const textHeight = 16;
                return x >= shape.x && x <= shape.x + textWidth && 
                       y >= shape.y - textHeight && y <= shape.y;
            }
            return false;
        }

        // Find shape at point
        function getShapeAtPoint(x, y) {
            for (let i = shapes.length - 1; i >= 0; i--) {
                if (isPointInShape(x, y, shapes[i])) {
                    return { shape: shapes[i], index: i };
                }
            }
            return null;
        }

        // Find all shapes at point (for cycling through overlapping shapes)
        function getAllShapesAtPoint(x, y) {
            const shapesAtPoint = [];
            for (let i = shapes.length - 1; i >= 0; i--) {
                if (isPointInShape(x, y, shapes[i])) {
                    shapesAtPoint.push({ shape: shapes[i], index: i });
                }
            }
            return shapesAtPoint;
        }

        // Get next shape in cycle when clicking on overlapping shapes
        function getNextShapeInCycle(x, y) {
            const shapesAtPoint = getAllShapesAtPoint(x, y);
            if (shapesAtPoint.length === 0) return null;
            
            // If no shape is currently selected, select the topmost one
            if (!selectedShape) {
                return shapesAtPoint[0];
            }
            
            // Find the currently selected shape in the list
            const currentIndex = shapesAtPoint.findIndex(item => item.shape === selectedShape);
            
            if (currentIndex === -1) {
                // Selected shape is not at this point, select the topmost one
                return shapesAtPoint[0];
            }
            
            // If the user has moved the mouse (indicating a drag), keep the current selection
            if (hasMoved) {
                return { shape: selectedShape, index: shapes.indexOf(selectedShape) };
            }
            
            // Cycle to the next shape in the list
            const nextIndex = (currentIndex + 1) % shapesAtPoint.length;
            return shapesAtPoint[nextIndex];
        }

        // Calculate rotation handle position
        function getRotationHandle(shape) {
            if (shape.type === 'rect' || shape.type === 'ellipse') {
                const centerX = shape.x + shape.w / 2;
                const centerY = shape.y + shape.h / 2;
                const handleDistance = Math.max(Math.abs(shape.w), Math.abs(shape.h)) / 2 + 20;
                return {
                    x: centerX + handleDistance * Math.cos(shape.rotation || 0),
                    y: centerY + handleDistance * Math.sin(shape.rotation || 0),
                    centerX: centerX,
                    centerY: centerY
                };
            } else if (shape.type === 'text') {
                const handleDistance = 30;
                return {
                    x: shape.x + handleDistance * Math.cos(shape.rotation || 0),
                    y: shape.y - 10 + handleDistance * Math.sin(shape.rotation || 0),
                    centerX: shape.x,
                    centerY: shape.y
                };
            }
            return null;
        }

        // Check if point is near rotation handle
        function isPointNearRotationHandle(x, y, shape) {
            const handle = getRotationHandle(shape);
            if (!handle) return false;
            
            const distance = Math.sqrt((x - handle.x) ** 2 + (y - handle.y) ** 2);
            return distance <= 10; // 10px radius for handle
        }

        // Get resize handles for a shape
        function getResizeHandles(shape) {
            if (shape.type !== 'rect' && shape.type !== 'ellipse') return [];
            
            const handles = [];
            const size = 8;
            
            // Corner handles
            handles.push({ x: shape.x, y: shape.y, type: 'nw', cursor: 'nw-resize' });
            handles.push({ x: shape.x + shape.w, y: shape.y, type: 'ne', cursor: 'ne-resize' });
            handles.push({ x: shape.x + shape.w, y: shape.y + shape.h, type: 'se', cursor: 'se-resize' });
            handles.push({ x: shape.x, y: shape.y + shape.h, type: 'sw', cursor: 'sw-resize' });
            
            // Edge handles
            handles.push({ x: shape.x + shape.w/2, y: shape.y, type: 'n', cursor: 'n-resize' });
            handles.push({ x: shape.x + shape.w, y: shape.y + shape.h/2, type: 'e', cursor: 'e-resize' });
            handles.push({ x: shape.x + shape.w/2, y: shape.y + shape.h, type: 's', cursor: 's-resize' });
            handles.push({ x: shape.x, y: shape.y + shape.h/2, type: 'w', cursor: 'w-resize' });
            
            return handles;
        }

        // Check if point is near any resize handle
        function isPointNearResizeHandle(x, y, shape) {
            const handles = getResizeHandles(shape);
            for (const handle of handles) {
                const distance = Math.sqrt((x - handle.x) ** 2 + (y - handle.y) ** 2);
                if (distance <= 8) {
                    return handle;
                }
            }
            return null;
        }

        // Calculate angle between two points
        function calculateAngle(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }

        // Update button states
        function updateButtonStates() {
            undoBtn.disabled = shapes.length === 0;
            deleteBtn.disabled = selectedShape === null;
        }

        // Update image info
        function updateImageInfo() {
            if (img) {
                const originalSize = `${img.naturalWidth} × ${img.naturalHeight}`;
                const displaySize = `${canvas.width} × ${canvas.height}`;
                imageInfo.textContent = `Image: ${originalSize} → Display: ${displaySize}`;
            } else {
                imageInfo.textContent = 'No image loaded';
            }
        }

        // Undo last action
        undoBtn.onclick = () => {
            if (shapes.length > 0) {
                shapes.pop();
                selectedShape = null;
                redraw();
                updateButtonStates();
            }
        };

        // Delete selected shape
        deleteBtn.onclick = () => {
            console.log('Delete button clicked');
            console.log('Selected shape:', selectedShape);
            console.log('Shapes array:', shapes);
            
            if (selectedShape) {
                const index = shapes.indexOf(selectedShape);
                console.log('Shape index:', index);
                
                if (index > -1) {
                    shapes.splice(index, 1);
                    selectedShape = null;
                    redraw();
                    updateButtonStates();
                    console.log('Shape deleted successfully');
                } else {
                    console.error('Shape not found in array');
                }
            } else {
                console.log('No shape selected');
            }
        };

        document.getElementsByName('tool').forEach(radio => {
            radio.addEventListener('change', e => { 
                tool = e.target.value; 
                selectedShape = null;
                updateButtonStates();
                redraw();
            });
        });
        document.getElementById('color').addEventListener('input', e => { color = e.target.value; });
        document.getElementById('size').addEventListener('input', e => { size = parseInt(e.target.value); });
        document.getElementById('clear').onclick = () => { 
            shapes = []; 
            selectedShape = null;
            redraw();
            updateButtonStates();
        };
        document.getElementById('download').onclick = () => {
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = canvas.toDataURL();
            link.click();
        };
        
        document.getElementById('imgLoader').onchange = async e => {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log('File selected:', file.name, 'Type:', file.type);
            
            try {
                let processedFile = file;
                
                // Check if it's a HEIC/HEIF file
                if (file.type === 'image/heic' || file.type === 'image/heif' || 
                    file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif')) {
                    
                    console.log('HEIC file detected, converting with heic2any...');
                    loading.style.display = 'block';
                    loading.textContent = 'Converting HEIC to JPEG...';
                    
                    try {
                        // Convert HEIC to JPEG using heic2any
                        processedFile = await convertHeicToJpeg(file);
                        console.log('HEIC conversion successful');
                        
                    } catch (heicError) {
                        loading.style.display = 'none';
                        console.error('HEIC conversion failed:', heicError);
                        
                        const shouldShowHelp = confirm(
                            'HEIC conversion failed: ' + heicError.message + '\n\n' +
                            'Would you like to see troubleshooting options?\n\n' +
                            'Click "OK" for help, "Cancel" to try a different file.'
                        );
                        
                        if (shouldShowHelp) {
                            showHeicHelp();
                        }
                        return;
                    }
                    
                    loading.style.display = 'none';
                }
                
                const reader = new FileReader();
                reader.onload = function(ev) {
                    const image = new Image();
                    image.onload = function() {
                        img = image;
                        resizeCanvas();
                        updateImageInfo();
                    };
                    image.src = ev.target.result;
                };
                reader.readAsDataURL(processedFile);
                
            } catch (error) {
                loading.style.display = 'none';
                console.error('Error processing image:', error);
                alert('Error loading image: ' + error.message);
            }
        };

        function redraw() {
            ctx.clearRect(0,0,canvas.width,canvas.height);
            if (img) {
                // Calculate scaling to fit image in canvas
                const scale = Math.min(
                    canvas.width / img.naturalWidth,
                    canvas.height / img.naturalHeight
                );
                
                const scaledWidth = img.naturalWidth * scale;
                const scaledHeight = img.naturalHeight * scale;
                
                // Center the image
                const x = (canvas.width - scaledWidth) / 2;
                const y = (canvas.height - scaledHeight) / 2;
                
                ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
                
                // Update scale factors for coordinate conversion
                canvasScale.x = scale;
                canvasScale.y = scale;
                canvasOffset.x = x;
                canvasOffset.y = y;
            }
            for (const s of shapes) drawShape(s, false);
        }

        function drawShape(s, temp) {
            ctx.save();
            ctx.strokeStyle = s.color;
            ctx.lineWidth = s.size;
            ctx.fillStyle = s.color;
            
            // Apply rotation if shape has rotation
            if (s.rotation && !temp) {
                const centerX = s.type === 'text' ? s.x : s.x + s.w / 2;
                const centerY = s.type === 'text' ? s.y : s.y + s.h / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(s.rotation);
                ctx.translate(-centerX, -centerY);
            }
            
            // Draw selection highlight
            if (s === selectedShape && !temp) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
            }
            
            if (s.type === 'rect') {
                ctx.strokeRect(s.x, s.y, s.w, s.h);
            } else if (s.type === 'ellipse') {
                ctx.beginPath();
                ctx.ellipse(s.x + s.w/2, s.y + s.h/2, Math.abs(s.w/2), Math.abs(s.h/2), 0, 0, 2*Math.PI);
                ctx.stroke();
            } else if (s.type === 'arrow') {
                drawArrow(s.x, s.y, s.x2, s.y2, s.color, s.size);
            } else if (s.type === 'text') {
                ctx.font = `${Math.max(16, s.size*6)}px sans-serif`;
                ctx.fillText(s.text, s.x, s.y);
            }
            
            ctx.restore();
            
            // Draw rotation handle for selected shapes
            if (s === selectedShape && !temp && (s.type === 'rect' || s.type === 'ellipse' || s.type === 'text')) {
                const handle = getRotationHandle(s);
                if (handle) {
                    ctx.save();
                    ctx.fillStyle = '#00ff00';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw rotation line
                    ctx.strokeStyle = '#00ff00';
                    ctx.setLineDash([3, 3]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(handle.centerX, handle.centerY);
                    ctx.lineTo(handle.x, handle.y);
                    ctx.stroke();
                    ctx.restore();
                }
            }
            
            // Draw resize handles for selected shapes
            if (s === selectedShape && !temp && (s.type === 'rect' || s.type === 'ellipse')) {
                const handles = getResizeHandles(s);
                ctx.save();
                ctx.fillStyle = '#ff0000';
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                for (const handle of handles) {
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        function drawArrow(x1, y1, x2, y2, color, size) {
            const headlen = 10 + size*2;
            const dx = x2 - x1, dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI/6), y2 - headlen * Math.sin(angle - Math.PI/6));
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI/6), y2 - headlen * Math.sin(angle + Math.PI/6));
            ctx.lineTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI/6), y2 - headlen * Math.sin(angle - Math.PI/6));
            ctx.stroke();
        }

        canvas.onmousedown = e => {
            const coords = screenToCanvas(e.clientX, e.clientY);
            const x = coords.x;
            const y = coords.y;
            
            // Store initial mouse position and reset movement flag
            mouseDownPos = { x, y };
            hasMoved = false;
            hasEdited = false;
            hadSelectionBeforeMouseDown = selectedShape !== null;
            
            if (tool === 'select') {
                // Check if clicking on resize handle
                if (selectedShape && (selectedShape.type === 'rect' || selectedShape.type === 'ellipse')) {
                    const resizeHandle = isPointNearResizeHandle(x, y, selectedShape);
                                         if (resizeHandle) {
                         isResizing = true;
                         hasEdited = true;
                         window.resizeHandle = resizeHandle;
                         originalShape = {
                             x: selectedShape.x,
                             y: selectedShape.y,
                             w: selectedShape.w,
                             h: selectedShape.h
                         };
                         return;
                     }
                }
                
                // Check if clicking on rotation handle
                if (selectedShape && isPointNearRotationHandle(x, y, selectedShape)) {
                    isRotating = true;
                    hasEdited = true;
                    rotationCenter = getRotationHandle(selectedShape);
                    rotationStartAngle = calculateAngle(rotationCenter.centerX, rotationCenter.centerY, x, y);
                    return;
                }
                
                // Only select a new shape if none is currently selected at this point
                const shapesAtPoint = getAllShapesAtPoint(x, y);
                if (shapesAtPoint.length > 0) {
                    // If we have a selected shape at this point, keep it for potential drag
                    if (selectedShape && shapesAtPoint.find(item => item.shape === selectedShape)) {
                        // Keep current selection, just set up for drag
                        dragOffset.x = x - selectedShape.x;
                        dragOffset.y = y - selectedShape.y;
                        isDragging = true;
                    } else {
                        // Select the topmost shape at this point
                        selectedShape = shapesAtPoint[0].shape;
                        dragOffset.x = x - selectedShape.x;
                        dragOffset.y = y - selectedShape.y;
                        isDragging = true;
                        updateButtonStates();
                        redraw();
                    }
                } else {
                    // No shapes at this point, deselect
                    selectedShape = null;
                    updateButtonStates();
                    redraw();
                }
            } else if (tool === 'text') {
                const text = prompt('Enter text:');
                if (text) {
                    shapes.push({ type: 'text', x, y, text, color, size, rotation: 0 });
                    redraw();
                    updateButtonStates();
                }
            } else {
                drawing = true;
                startX = x;
                startY = y;
            }
        };

        canvas.onmouseup = e => {
            if (!drawing && tool !== 'select') return;
            const coords = screenToCanvas(e.clientX, e.clientY);
            const x = coords.x;
            const y = coords.y;
            
            if (tool === 'select') {
                // Only cycle if user didn't move significantly AND had a selection before mouse down AND didn't perform any edit operations
                if (!hasMoved && !hasEdited && selectedShape && hadSelectionBeforeMouseDown) {
                    const shapesAtPoint = getAllShapesAtPoint(x, y);
                    if (shapesAtPoint.length > 1) {
                        const currentIndex = shapesAtPoint.findIndex(item => item.shape === selectedShape);
                        if (currentIndex !== -1) {
                            const nextIndex = (currentIndex + 1) % shapesAtPoint.length;
                            selectedShape = shapesAtPoint[nextIndex].shape;
                            redraw();
                            updateButtonStates();
                        }
                    }
                }
            } else if (tool === 'rect' || tool === 'ellipse') {
                shapes.push({ type: tool, x: startX, y: startY, w: x-startX, h: y-startY, color, size, rotation: 0 });
            } else if (tool === 'arrow') {
                shapes.push({ type: 'arrow', x: startX, y: startY, x2: x, y2: y, color, size });
            }
            
            drawing = false;
            isDragging = false;
            isRotating = false;
            isResizing = false;
            redraw();
            updateButtonStates();
        };

        // Handle keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedShape) {
                    console.log('Delete key pressed - deleting selected shape');
                    const index = shapes.indexOf(selectedShape);
                    if (index > -1) {
                        shapes.splice(index, 1);
                        selectedShape = null;
                        redraw();
                        updateButtonStates();
                        console.log('Shape deleted via keyboard');
                    }
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                // Ctrl+Z or Cmd+Z for undo
                e.preventDefault();
                if (shapes.length > 0) {
                    shapes.pop();
                    selectedShape = null;
                    redraw();
                    updateButtonStates();
                    console.log('Undo via Ctrl+Z');
                }
            }
        });

        // Update cursor based on mouse position
        canvas.onmousemove = e => {
            const coords = screenToCanvas(e.clientX, e.clientY);
            const x = coords.x;
            const y = coords.y;
            
            // Check if mouse has moved significantly (indicating a drag)
            if (isDragging && !hasMoved) {
                const distance = Math.sqrt((x - mouseDownPos.x) ** 2 + (y - mouseDownPos.y) ** 2);
                if (distance > 5) { // 5px threshold for movement
                    hasMoved = true;
                    hasEdited = true;
                }
            }
            
            // Update cursor for handles
            if (tool === 'select' && selectedShape) {
                if (selectedShape.type === 'rect' || selectedShape.type === 'ellipse') {
                    const resizeHandle = isPointNearResizeHandle(x, y, selectedShape);
                    if (resizeHandle) {
                        canvas.style.cursor = resizeHandle.cursor;
                    } else if (isPointNearRotationHandle(x, y, selectedShape)) {
                        canvas.style.cursor = 'grab';
                    } else {
                        canvas.style.cursor = 'move';
                    }
                } else if (isPointNearRotationHandle(x, y, selectedShape)) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'move';
                }
            } else if (tool === 'select') {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'crosshair';
            }
            
            if (tool === 'select') {
                if (isResizing && selectedShape && window.resizeHandle && originalShape) {
                    const deltaX = x - mouseDownPos.x;
                    const deltaY = y - mouseDownPos.y;
                    
                    switch (window.resizeHandle.type) {
                        case 'nw':
                            selectedShape.x = originalShape.x + deltaX;
                            selectedShape.y = originalShape.y + deltaY;
                            selectedShape.w = originalShape.w - deltaX;
                            selectedShape.h = originalShape.h - deltaY;
                            break;
                        case 'ne':
                            selectedShape.y = originalShape.y + deltaY;
                            selectedShape.w = originalShape.w + deltaX;
                            selectedShape.h = originalShape.h - deltaY;
                            break;
                        case 'se':
                            selectedShape.w = originalShape.w + deltaX;
                            selectedShape.h = originalShape.h + deltaY;
                            break;
                        case 'sw':
                            selectedShape.x = originalShape.x + deltaX;
                            selectedShape.w = originalShape.w - deltaX;
                            selectedShape.h = originalShape.h + deltaY;
                            break;
                        case 'n':
                            selectedShape.y = originalShape.y + deltaY;
                            selectedShape.h = originalShape.h - deltaY;
                            break;
                        case 'e':
                            selectedShape.w = originalShape.w + deltaX;
                            break;
                        case 's':
                            selectedShape.h = originalShape.h + deltaY;
                            break;
                        case 'w':
                            selectedShape.x = originalShape.x + deltaX;
                            selectedShape.w = originalShape.w - deltaX;
                            break;
                    }
                    
                    // Ensure minimum size
                    if (selectedShape.w < 10) selectedShape.w = 10;
                    if (selectedShape.h < 10) selectedShape.h = 10;
                    
                    redraw();
                } else if (isRotating && selectedShape && rotationCenter) {
                    const currentAngle = calculateAngle(rotationCenter.centerX, rotationCenter.centerY, x, y);
                    const deltaAngle = currentAngle - rotationStartAngle;
                    selectedShape.rotation = (selectedShape.rotation || 0) + deltaAngle;
                    rotationStartAngle = currentAngle;
                    redraw();
                } else if (isDragging && selectedShape) {
                    selectedShape.x = x - dragOffset.x;
                    selectedShape.y = y - dragOffset.y;
                    redraw();
                }
            } else if (drawing && tool !== 'text') {
                redraw();
                if (tool === 'rect' || tool === 'ellipse') {
                    drawShape({ type: tool, x: startX, y: startY, w: x-startX, h: y-startY, color, size }, true);
                } else if (tool === 'arrow') {
                    drawShape({ type: 'arrow', x: startX, y: startY, x2: x, y2: y, color, size }, true);
                }
            }
        };

        canvas.onclick = e => {
            if (tool !== 'text') return;
            const coords = screenToCanvas(e.clientX, e.clientY);
            const x = coords.x;
            const y = coords.y;
            const text = prompt('Enter text:');
            if (text) {
                shapes.push({ type: 'text', x, y, text, color, size });
                redraw();
                updateButtonStates();
            }
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
        });

        // Initialize
        resizeCanvas();
        updateButtonStates();
        updateImageInfo();
    </script>
</body>
</html>
